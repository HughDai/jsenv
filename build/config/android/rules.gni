# Copyright (c) 2021, the hapjs-platform Project Contributors
# SPDX-License-Identifier: EPL-1.0

import("//build/config/android/config.gni")
import("//build/config/android/internal_rules.gni")
import("//build/config/java/rules.gni")

assert(is_android)

declare_args() {
  enable_java_templates = false
}

# Declare a jni target
#
# This target generates the native jni bindings for a set of .java files.
#
# See base/android/jni_generator/jni_generator.py for more info about the
# format of generating JNI bindings.
#
# Variables
#   sources: list of .java files to generate jni for
#   jni_package: subdirectory path for generated bindings
#
# Example
#   generate_jni("foo_jni") {
#     sources = [
#       "android/java/src/org/chromium/foo/Foo.java",
#       "android/java/src/org/chromium/foo/FooUtil.java",
#     ]
#     jni_package = "foo"
#   }
template("generate_jni") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  assert(defined(invoker.sources))
  assert(defined(invoker.jni_package))
  jni_package = invoker.jni_package
  base_output_dir = "${target_gen_dir}/${target_name}"
  package_output_dir = "${base_output_dir}/${jni_package}"
  jni_output_dir = "${package_output_dir}/jni"

  jni_generator_include = "//base/android/jni_generator/jni_generator_helper.h"

  foreach_target_name = "${target_name}__jni_gen"
  action_foreach(foreach_target_name) {
    script = "//base/android/jni_generator/jni_generator.py"
    depfile = "$target_gen_dir/$target_name.{{source_name_part}}.d"
    sources = invoker.sources
    outputs = [
      depfile,
      "${jni_output_dir}/{{source_name_part}}_jni.h",
    ]

    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--input_file={{source}}",
      "--optimize_generation=1",
      "--ptr_type=long",
      "--output_dir",
      rebase_path(jni_output_dir, root_build_dir),
      "--includes",
      rebase_path(jni_generator_include, jni_output_dir),
      "--native_exports_optional",
    ]
    if (defined(invoker.jni_generator_jarjar_file)) {
      args += [
        "--jarjar",
        rebase_path(jni_generator_jarjar_file, root_build_dir),
      ]
    }
  }

  config("jni_includes_${target_name}") {
    # TODO(cjhopman): #includes should probably all be relative to
    # base_output_dir. Remove that from this config once the includes are
    # updated.
    include_dirs = [
      base_output_dir,
      package_output_dir,
    ]
  }

  group(target_name) {
    deps = [
      ":$foreach_target_name",
    ]
    public_configs = [ ":jni_includes_${target_name}" ]

    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
    if (defined(invoker.public_deps)) {
      public_deps = invoker.public_deps
    }

    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }
  }
}

# Declare a jni target for a prebuilt jar
#
# This target generates the native jni bindings for a set of classes in a .jar.
#
# See base/android/jni_generator/jni_generator.py for more info about the
# format of generating JNI bindings.
#
# Variables
#   classes: list of .class files in the jar to generate jni for. These should
#     include the full path to the .class file.
#   jni_package: subdirectory path for generated bindings
#   jar_file: the path to the .jar. If not provided, will default to the sdk's
#     android.jar
#
#   deps, public_deps: As normal
#
# Example
#   generate_jar_jni("foo_jni") {
#     classes = [
#       "android/view/Foo.class",
#     ]
#     jni_package = "foo"
#   }
template("generate_jar_jni") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  assert(defined(invoker.classes))
  assert(defined(invoker.jni_package))

  if (defined(invoker.jar_file)) {
    jar_file = invoker.jar_file
  } else {
    jar_file = android_sdk_jar
  }

  jni_package = invoker.jni_package
  base_output_dir = "${root_gen_dir}/${target_name}/${jni_package}"
  jni_output_dir = "${base_output_dir}/jni"

  jni_generator_include = "//base/android/jni_generator/jni_generator_helper.h"

  # TODO(cjhopman): make jni_generator.py support generating jni for multiple
  # .class files from a .jar.
  jni_actions = []
  foreach(class, invoker.classes) {
    _classname_list = []
    _classname_list = process_file_template([ class ], "{{source_name_part}}")
    classname = _classname_list[0]
    jni_target_name = "${target_name}__jni_${classname}"
    jni_actions += [ ":$jni_target_name" ]
    action(jni_target_name) {
      # The sources aren't compiled so don't check their dependencies.
      check_includes = false
      depfile = "$target_gen_dir/$target_name.d"
      script = "//base/android/jni_generator/jni_generator.py"
      sources = [
        jar_file,
      ]
      outputs = [
        depfile,
        "${jni_output_dir}/${classname}_jni.h",
      ]

      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--jar_file",
        rebase_path(jar_file, root_build_dir),
        "--input_file",
        class,
        "--optimize_generation=1",
        "--ptr_type=long",
        "--output_dir",
        rebase_path(jni_output_dir, root_build_dir),
        "--includes",
        rebase_path(jni_generator_include, jni_output_dir),
        "--native_exports_optional",
      ]
    }
  }

  config("jni_includes_${target_name}") {
    include_dirs = [ base_output_dir ]
  }

  group(target_name) {
    deps = jni_actions
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
    if (defined(invoker.public_deps)) {
      public_deps = invoker.public_deps
    }
    public_configs = [ ":jni_includes_${target_name}" ]
  }
}

# Declare a target for c-preprocessor-generated java files
#
# NOTE: For generating Java conterparts to enums prefer using the java_cpp_enum
#       rule instead.
#
# This target generates java files using the host C pre-processor. Each file in
# sources will be compiled using the C pre-processor. If include_path is
# specified, it will be passed (with --I) to the pre-processor.
#
# This target will create a single .srcjar. Adding this target to an
# android_library target's srcjar_deps will make the generated java files be
# included in that library's final outputs.
#
# Variables
#   sources: list of files to be processed by the C pre-processor. For each
#     file in sources, there will be one .java file in the final .srcjar. For a
#     file named FooBar.template, a java file will be created with name
#     FooBar.java.
#   inputs: additional compile-time dependencies. Any files
#     `#include`-ed in the templates should be listed here.
#   package_name: this will be the subdirectory for each .java file in the
#     .srcjar.
#
# Example
#   java_cpp_template("foo_generated_enum") {
#     sources = [
#       "android/java/templates/Foo.template",
#     ]
#     inputs = [
#       "android/java/templates/native_foo_header.h",
#     ]
#
#     package_name = "org/chromium/base/library_loader"
#     include_path = "android/java/templates"
#   }
template("java_cpp_template") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  assert(defined(invoker.sources))
  package_name = invoker.package_name + ""

  if (defined(invoker.include_path)) {
    include_path = invoker.include_path + ""
  } else {
    include_path = "//"
  }

  apply_gcc_target_name = "${target_name}__apply_gcc"
  zip_srcjar_target_name = "${target_name}__zip_srcjar"
  final_target_name = target_name

  action_foreach(apply_gcc_target_name) {
    visibility = [ ":$zip_srcjar_target_name" ]
    script = "//build/android/gyp/gcc_preprocess.py"
    if (defined(invoker.inputs)) {
      inputs = invoker.inputs + []
    }
    depfile = "${target_gen_dir}/${target_name}_{{source_name_part}}.d"

    sources = invoker.sources

    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
    if (defined(invoker.public_deps)) {
      public_deps = invoker.public_deps
    }
    if (defined(invoker.data_deps)) {
      data_deps = invoker.data_deps
    }

    gen_dir =
        "${target_gen_dir}/${target_name}/java_cpp_template/${package_name}"
    gcc_template_output_pattern = "${gen_dir}/{{source_name_part}}.java"

    outputs = [
      depfile,
      gcc_template_output_pattern,
    ]

    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--include-path",
      rebase_path(include_path, root_build_dir),
      "--output",
      rebase_path(gen_dir, root_build_dir) + "/{{source_name_part}}.java",
      "--template={{source}}",
    ]

    if (defined(invoker.defines)) {
      foreach(def, invoker.defines) {
        args += [
          "--defines",
          def,
        ]
      }
    }
  }

  apply_gcc_outputs = get_target_outputs(":$apply_gcc_target_name")
  base_gen_dir = get_label_info(":$apply_gcc_target_name", "target_gen_dir")

  srcjar_path = "${target_gen_dir}/${target_name}.srcjar"
  zip(zip_srcjar_target_name) {
    visibility = [ ":$final_target_name" ]
    inputs = apply_gcc_outputs
    output = srcjar_path
    base_dir = base_gen_dir
    deps = [
      ":$apply_gcc_target_name",
    ]
  }

  group(final_target_name) {
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }
    public_deps = [
      ":$zip_srcjar_target_name",
    ]
  }
}

# Declare a target for generating Java classes from C++ enums.
#
# This target generates Java files from C++ enums using a script.
#
# This target will create a single .srcjar. Adding this target to an
# android_library target's srcjar_deps will make the generated java files be
# included in that library's final outputs.
#
# Variables
#   sources: list of files to be processed by the script. For each annotated
#     enum contained in the sources files the script will generate a .java
#     file with the same name as the name of the enum.
#
#   outputs: list of outputs, relative to the output_dir. These paths are
#     verified at build time by the script. To get the list programatically run:
#       python build/android/gyp/java_cpp_enum.py \
#         --print_output_only . path/to/header/file.h
#
# Example
#   java_cpp_enum("foo_generated_enum") {
#     sources = [
#       "src/native_foo_header.h",
#     ]
#     outputs = [
#       "org/chromium/FooEnum.java",
#     ]
#   }
template("java_cpp_enum") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  assert(defined(invoker.sources))
  assert(defined(invoker.outputs))

  generate_enum_target_name = "${target_name}__generate_enum"
  zip_srcjar_target_name = "${target_name}__zip_srcjar"
  final_target_name = target_name

  action(generate_enum_target_name) {
    visibility = [ ":$zip_srcjar_target_name" ]

    # The sources aren't compiled so don't check their dependencies.
    check_includes = false

    sources = invoker.sources
    script = "//build/android/gyp/java_cpp_enum.py"
    gen_dir = "${target_gen_dir}/${target_name}/enums"
    outputs =
        get_path_info(rebase_path(invoker.outputs, ".", gen_dir), "abspath")

    args = []
    foreach(output, rebase_path(outputs, root_build_dir)) {
      args += [
        "--assert_file",
        output,
      ]
    }
    args += [ rebase_path(gen_dir, root_build_dir) ]
    args += rebase_path(invoker.sources, root_build_dir)
  }

  generate_enum_outputs = get_target_outputs(":$generate_enum_target_name")
  base_gen_dir = get_label_info(":$generate_enum_target_name", "target_gen_dir")

  srcjar_path = "${target_gen_dir}/${target_name}.srcjar"
  zip(zip_srcjar_target_name) {
    visibility = [ ":$final_target_name" ]
    inputs = generate_enum_outputs
    output = srcjar_path
    base_dir = base_gen_dir
    public_deps = [
      ":$generate_enum_target_name",
    ]
  }

  group(final_target_name) {
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }
    public_deps = [
      ":$zip_srcjar_target_name",
    ]
  }
}

# Declare a target for processing Android resources as Jinja templates.
#
# This takes an Android resource directory where each resource is a Jinja
# template, processes each template, then packages the results in a zip file
# which can be consumed by an android resources, library, or apk target.
#
# If this target is included in the deps of an android resources/library/apk,
# the resources will be included with that target.
#
# Variables
#   resources: The list of resources files to process.
#   res_dir: The resource directory containing the resources.
#   variables: (Optional) A list of variables to make available to the template
#     processing environment, e.g. ["name=foo", "color=red"].
#
# Example
#   jinja_template_resources("chrome_shell_template_resources") {
#     res_dir = "shell/res_template"
#     resources = ["shell/res_template/xml/syncable.xml"]
#     variables = ["color=red"]
#   }
template("jinja_template_resources") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  assert(defined(invoker.resources))
  assert(defined(invoker.res_dir))

  _base_path = "$target_gen_dir/$target_name"
  _resources_zip = _base_path + ".resources.zip"
  _build_config = _base_path + ".build_config"

  write_build_config("${target_name}__build_config") {
    build_config = _build_config
    resources_zip = _resources_zip
    type = "android_resources"
  }

  action("${target_name}__template") {
    sources = invoker.resources
    script = "//build/android/gyp/jinja_template.py"
    depfile = "$target_gen_dir/$target_name.d"

    outputs = [
      depfile,
      _resources_zip,
    ]

    rebased_resources = rebase_path(invoker.resources, root_build_dir)
    args = [
      "--inputs=${rebased_resources}",
      "--inputs-base-dir",
      rebase_path(invoker.res_dir, root_build_dir),
      "--outputs-zip",
      rebase_path(_resources_zip, root_build_dir),
      "--depfile",
      rebase_path(depfile, root_build_dir),
    ]
    if (defined(invoker.variables)) {
      variables = invoker.variables
      args += [ "--variables=${variables}" ]
    }
  }

  group(target_name) {
    deps = [
      ":${target_name}__build_config",
      ":${target_name}__template",
    ]
  }
}

# Creates a resources.zip with locale.pak files placed into appropriate
# resource configs (e.g. en-GB.pak -> res/raw-en/en_gb.pak). Also generates
# a locale_paks TypedArray so that resource files can be enumerated at runtime.
#
# If this target is included in the deps of an android resources/library/apk,
# the resources will be included with that target.
#
# Variables:
#   sources: List of .pak files. Names must be of the form "en.pak" or
#       "en-US.pak".
#   deps: (optional) List of dependencies that might be needed to generate
#       the .pak files.
#
# Example
#   locale_pak_resources("locale_paks") {
#     sources = [ "path/en-US.pak", "path/fr.pak", ... ]
#   }
template("locale_pak_resources") {
  set_sources_assignment_filter([])
  assert(defined(invoker.sources))

  _base_path = "$target_gen_dir/$target_name"
  _resources_zip = _base_path + ".resources.zip"
  _build_config = _base_path + ".build_config"

  write_build_config("${target_name}__build_config") {
    build_config = _build_config
    resources_zip = _resources_zip
    type = "android_resources"
  }

  action("${target_name}__create_resources_zip") {
    sources = invoker.sources
    script = "//build/android/gyp/locale_pak_resources.py"
    depfile = "$target_gen_dir/$target_name.d"

    outputs = [
      depfile,
      _resources_zip,
    ]

    _rebased_sources = rebase_path(invoker.sources, root_build_dir)
    args = [
      "--locale-paks=${_rebased_sources}",
      "--resources-zip",
      rebase_path(_resources_zip, root_build_dir),
      "--depfile",
      rebase_path(depfile, root_build_dir),
    ]

    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
  }

  group(target_name) {
    deps = [
      ":${target_name}__build_config",
      ":${target_name}__create_resources_zip",
    ]
  }
}

# Example
#   android_resources("foo_resources") {
#     deps = [":foo_strings_grd"]
#     resource_dirs = ["res"]
#     custom_package = "org.chromium.foo"

# Declare a target that generates localized strings.xml from a .grd file.
#
# If this target is included in the deps of an android resources/library/apk,
# the strings.xml will be included with that target.
#
# Variables
#   deps: Specifies the dependencies of this target.
#   grd_file: Path to the .grd file to generate strings.xml from.
#   outputs: Expected grit outputs (see grit rule).
#
# Example
#  java_strings_grd("foo_strings_grd") {
#    grd_file = "foo_strings.grd"
#  }
template("java_strings_grd") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  base_path = "$target_gen_dir/$target_name"
  resources_zip = base_path + ".resources.zip"
  build_config = base_path + ".build_config"

  write_build_config("${target_name}__build_config") {
    type = "android_resources"
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
  }

  # Put grit files into this subdirectory of target_gen_dir.
  extra_output_path = target_name + "_grit_output"

  grit_target_name = "${target_name}__grit"
  grit_output_dir = "$target_gen_dir/$extra_output_path"
  grit(grit_target_name) {
    grit_flags = [
      "-E",
      "ANDROID_JAVA_TAGGED_ONLY=false",
    ]
    output_dir = grit_output_dir
    resource_ids = ""
    source = invoker.grd_file
    outputs = invoker.outputs
  }

  # This needs to get outputs from grit's internal target, not the final
  # source_set.
  generate_strings_outputs = get_target_outputs(":${grit_target_name}_grit")

  zip("${target_name}__zip") {
    base_dir = grit_output_dir
    inputs = generate_strings_outputs
    output = resources_zip
    deps = [
      ":$grit_target_name",
    ]
  }

  group(target_name) {
    deps = [
      ":${target_name}__build_config",
      ":${target_name}__zip",
    ]
  }
}

# Declare a target that packages strings.xml generated from a grd file.
#
# If this target is included in the deps of an android resources/library/apk,
# the strings.xml will be included with that target.
#
# Variables
#  grit_output_dir: directory containing grit-generated files.
#  generated_files: list of android resource files to package.
#
# Example
#  java_strings_grd_prebuilt("foo_strings_grd") {
#    grit_output_dir = "$root_gen_dir/foo/grit"
#    generated_files = [
#      "values/strings.xml"
#    ]
#  }
template("java_strings_grd_prebuilt") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  base_path = "$target_gen_dir/$target_name"
  resources_zip = base_path + ".resources.zip"
  build_config = base_path + ".build_config"

  build_config_target_name = "${target_name}__build_config"
  zip_target_name = "${target_name}__zip"
  final_target_name = target_name

  write_build_config(build_config_target_name) {
    visibility = [ ":$zip_target_name" ]
    type = "android_resources"
  }

  zip(zip_target_name) {
    visibility = [ ":$final_target_name" ]

    base_dir = invoker.grit_output_dir
    inputs = rebase_path(invoker.generated_files, ".", base_dir)
    output = resources_zip
    deps = [
      ":$build_config_target_name",
    ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }

  group(final_target_name) {
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }
    deps = [
      ":$zip_target_name",
    ]
  }
}

# Declare a Junit executable target
#
# This target creates an executable from java code for running as a junit test
# suite. The executable will be in the output folder's /bin/ directory.
#
# Variables
#   deps: Specifies the dependencies of this target. Java targets in this list
#     will be included in the executable (and the javac classpath).
#
#   java_files: List of .java files included in this library.
#   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
#     will be added to java_files and be included in this library.
#   srcjars: List of srcjars to be included in this library, together with the
#     ones obtained from srcjar_deps.
#
#   chromium_code: If true, extra analysis warning/errors will be enabled.
#
# Example
#   junit_binary("foo") {
#     java_files = [ "org/chromium/foo/FooTest.java" ]
#     deps = [ ":bar_java" ]
#   }
template("junit_binary") {
  set_sources_assignment_filter([])

  java_binary(target_name) {
    bypass_platform_checks = true
    main_class = "org.chromium.testing.local.JunitTestMain"
    testonly = true

    if (defined(invoker.DEPRECATED_java_in_dir)) {
      DEPRECATED_java_in_dir = invoker.DEPRECATED_java_in_dir
    }
    if (defined(invoker.chromium_code)) {
      chromium_code = invoker.chromium_code
    }
    deps = [
      "//testing/android/junit:junit_test_support",
      "//third_party/junit",
      "//third_party/mockito:mockito_java",
      "//third_party/robolectric:android-all-4.3_r2-robolectric-0",
      "//third_party/robolectric:robolectric_java",
    ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
    if (defined(invoker.java_files)) {
      java_files = invoker.java_files
    }
    if (defined(invoker.srcjar_deps)) {
      srcjar_deps = invoker.srcjar_deps
    }
    if (defined(invoker.srcjars)) {
      srcjars = invoker.srcjars
    }
  }
}

# Declare a target that packages a set of Java dependencies into a standalone
# .dex.jar.
#
# Variables
#   deps: specifies the dependencies of this target. Android libraries in deps
#     will be packaged into the resulting .dex.jar file.
#   dex_path: location at which the output file will be put
template("android_standalone_library") {
  set_sources_assignment_filter([])
  deps_dex(target_name) {
    deps = invoker.deps
    dex_path = invoker.dex_path
    if (defined(invoker.excluded_jars)) {
      excluded_jars = invoker.excluded_jars
    }
  }
}

# Declare an Android library target for a prebuilt jar
#
# This target creates an Android library containing java code and Android
# resources.
#
# Variables
#   deps: Specifies the dependencies of this target. Java targets in this list
#     will be added to the javac classpath. Android resources in dependencies
#     will be used when building this library.
#   jar_path: Path to the prebuilt jar.
#   proguard_preprocess: If true, proguard preprocessing will be run. This can
#     be used to remove unwanted parts of the library.
#   proguard_config: Path to the proguard config for preprocessing.
#
# Example
#   android_java_prebuilt("foo_java") {
#     jar_path = "foo.jar"
#     deps = [
#       ":foo_resources",
#       ":bar_java"
#     ]
#   }
template("android_java_prebuilt") {
  set_sources_assignment_filter([])
  java_prebuilt_impl(target_name) {
    jar_path = invoker.jar_path
    supports_android = true
    requires_android = true
    if (defined(invoker.testonly)) {
      testonly = invoker.testonly
    }
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
    if (defined(invoker.data_deps)) {
      data_deps = invoker.data_deps
    }
    if (defined(invoker.proguard_config)) {
      proguard_config = invoker.proguard_config
    }
    if (defined(invoker.proguard_preprocess)) {
      proguard_preprocess = invoker.proguard_preprocess
    }
  }
}

template("instrumentation_test_apk") {
  set_sources_assignment_filter([])
  testonly = true
  _template_name = target_name

  if (defined(invoker.apk_name)) {
    test_runner_data_dep = [ ":${_template_name}__test_runner_script" ]
    test_runner_script("${_template_name}__test_runner_script") {
      test_name = invoker.target_name
      test_type = "instrumentation"
      test_apk = invoker.apk_name
      if (defined(invoker.isolate_file)) {
        isolate_file = invoker.isolate_file
      }
      if (defined(invoker.support_apk_path)) {
        support_apk_path = invoker.support_apk_path
      }
    }
  }

  android_apk(target_name) {
    if (defined(invoker.android_manifest)) {
      android_manifest = invoker.android_manifest
    }
    data_deps = [
      "//testing/android/driver:driver_apk",
      "//tools/android/forwarder2",
      "//tools/android/md5sum",
    ]
    if (defined(test_runner_data_dep)) {
      data_deps += test_runner_data_dep
    }
    if (defined(invoker.data_deps)) {
      data_deps += invoker.data_deps
    }
    deps = [
      "//testing/android/broker:broker_java",
    ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
    if (defined(invoker.java_files)) {
      java_files = invoker.java_files
    }
    if (defined(invoker.srcjar_deps)) {
      srcjar_deps = invoker.srcjar_deps
    }
    if (defined(invoker.apk_name)) {
      apk_name = invoker.apk_name
    }
    if (defined(invoker.final_apk_path)) {
      final_apk_path = invoker.final_apk_path
    }
    if (defined(invoker.native_libs)) {
      native_libs = invoker.native_libs
    }
    if (defined(invoker.apk_under_test)) {
      apk_under_test = invoker.apk_under_test
    }
    if (defined(invoker.DEPRECATED_java_in_dir)) {
      DEPRECATED_java_in_dir = invoker.DEPRECATED_java_in_dir
    }
  }
}

# Declare an Android gtest apk
#
# This target creates an Android apk for running gtest-based unittests.
#
# Variables
#   deps: Specifies the dependencies of this target. These will be passed to
#     the underlying android_apk invocation and should include the java and
#     resource dependencies of the apk.
#   unittests_dep: This should be the label of the gtest native target. This
#     target must be defined previously in the same file.
#   unittests_binary: The basename of the library produced by the unittests_dep
#     target. If unspecified, it assumes the name of the unittests_dep target
#     (which will be correct unless that target specifies an "output_name".
#     TODO(brettw) make this automatic by allowing get_target_outputs to
#     support executables.
#   apk_name: The name of the produced apk. If unspecified, it uses the name
#             of the unittests_dep target postfixed with "_apk"
#
# Example
#   unittest_apk("foo_unittests_apk") {
#     deps = [ ":foo_java", ":foo_resources" ]
#     unittests_dep = ":foo_unittests"
#   }
template("unittest_apk") {
  set_sources_assignment_filter([])
  testonly = true

  assert(defined(invoker.unittests_dep), "Need unittests_dep for $target_name")

  test_suite_name = get_label_info(invoker.unittests_dep, "name")

  # This trivial assert is needed in case both unittests_binary and apk_name
  # are defined, as otherwise test_suite_name would not be used.
  assert(test_suite_name != "")

  if (defined(invoker.unittests_binary)) {
    unittests_binary = invoker.unittests_binary
  } else {
    unittests_binary = "lib${test_suite_name}${android_product_extension}"
  }

  if (defined(invoker.apk_name)) {
    apk_name = invoker.apk_name
  } else {
    apk_name = test_suite_name
  }

  android_apk(target_name) {
    final_apk_path = "$root_build_dir/${apk_name}_apk/${apk_name}-debug.apk"
    java_files = [
      "//testing/android/native_test/java/src/org/chromium/native_test/NativeBrowserTestActivity.java",
      "//testing/android/native_test/java/src/org/chromium/native_test/NativeTestActivity.java",
      "//testing/android/native_test/java/src/org/chromium/native_test/NativeUnitTestActivity.java",
      "//testing/android/native_test/java/src/org/chromium/native_test/NativeTestInstrumentationTestRunner.java",
    ]
    android_manifest = "//testing/android/native_test/java/AndroidManifest.xml"
    native_libs = [ unittests_binary ]
    if (defined(invoker.asset_location)) {
      asset_location = invoker.asset_location
    }
    deps = [
      "//base:base_java",
      "//build/android/pylib/remote/device/dummy:remote_device_dummy_apk",
      "//testing/android/appurify_support:appurify_support_java",
      "//testing/android/reporter:reporter_java",
    ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
    data_deps = [
      "//tools/android/md5sum",
    ]
    if (host_os == "linux") {
      data_deps += [ "//tools/android/forwarder2" ]
    }
    if (defined(invoker.data_deps)) {
      data_deps += invoker.data_deps
    }
  }
}

# Generate .java files from .aidl files.
#
# This target will store the .java files in a srcjar and should be included in
# an android_library or android_apk's srcjar_deps.
#
# Variables
#   sources: Paths to .aidl files to compile.
#   import_include: Path to directory containing .java files imported by the
#     .aidl files.
#   interface_file: Preprocessed aidl file to import.
#
# Example
#   android_aidl("foo_aidl") {
#     import_include = "java/src"
#     sources = [
#       "java/src/com/foo/bar/FooBarService.aidl",
#       "java/src/com/foo/bar/FooBarServiceCallback.aidl",
#     ]
#   }
template("android_aidl") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  srcjar_path = "${target_gen_dir}/${target_name}.srcjar"
  aidl_path = "${android_sdk_build_tools}/aidl"
  framework_aidl = "$android_sdk/framework.aidl"

  action(target_name) {
    script = "//build/android/gyp/aidl.py"
    sources = invoker.sources

    imports = [ framework_aidl ]
    if (defined(invoker.interface_file)) {
      assert(invoker.interface_file != "")
      imports += [ invoker.interface_file ]
    }

    inputs = [ aidl_path ] + imports

    depfile = "${target_gen_dir}/${target_name}.d"
    outputs = [
      depfile,
      srcjar_path,
    ]
    rebased_imports = rebase_path(imports, root_build_dir)
    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--aidl-path",
      rebase_path(aidl_path, root_build_dir),
      "--imports=$rebased_imports",
      "--srcjar",
      rebase_path(srcjar_path, root_build_dir),
    ]
    if (defined(invoker.import_include) && invoker.import_include != "") {
      # TODO(cjhopman): aidl supports creating a depfile. We should be able to
      # switch to constructing a depfile for the overall action from that
      # instead of having all the .java files in the include paths as inputs.
      rebased_import_includes =
          rebase_path([ invoker.import_include ], root_build_dir)
      args += [ "--includes=$rebased_import_includes" ]

      _java_files_build_rel =
          exec_script("//build/android/gyp/find.py",
                      rebase_path([ invoker.import_include ], root_build_dir),
                      "list lines")
      _java_files = rebase_path(_java_files_build_rel, ".", root_build_dir)
      inputs += _java_files
    }
    args += rebase_path(sources, root_build_dir)
  }
}

# Creates a dist directory for a native executable.
#
# Running a native executable on a device requires all the shared library
# dependencies of that executable. To make it easier to install and run such an
# executable, this will create a directory containing the native exe and all
# it's library dependencies.
#
# Note: It's usually better to package things as an APK than as a native
# executable.
#
# Variables
#   dist_dir: Directory for the exe and libraries. Everything in this directory
#     will be deleted before copying in the exe and libraries.
#   binary: Path to (stripped) executable.
#
# Example
#   create_native_executable_dist("foo_dist") {
#     dist_dir = "$root_build_dir/foo_dist"
#     binary = "$root_build_dir/exe.stripped/foo"
#     deps = [ ":the_thing_that_makes_foo" ]
#   }
template("create_native_executable_dist") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  dist_dir = invoker.dist_dir
  binary = invoker.binary
  template_name = target_name

  libraries_list =
      "${target_gen_dir}/${template_name}_library_dependencies.list"

  find_deps_target_name = "${template_name}__find_library_dependencies"
  copy_target_name = "${template_name}__copy_libraries_and_exe"

  stripped_libraries_dir = "$root_build_dir/lib.stripped"
  action(find_deps_target_name) {
    visibility = [ ":$copy_target_name" ]

    script = "//build/android/gyp/write_ordered_libraries.py"
    depfile = "$target_gen_dir/$target_name.d"
    inputs = [
      binary,
      android_readelf,
    ]
    outputs = [
      depfile,
      libraries_list,
    ]
    rebased_binaries = rebase_path([ binary ], root_build_dir)
    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--input-libraries=$rebased_binaries",
      "--libraries-dir",
      rebase_path(stripped_libraries_dir, root_build_dir),
      "--output",
      rebase_path(libraries_list, root_build_dir),
      "--readelf",
      rebase_path(android_readelf, root_build_dir),
    ]
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
  }

  copy_ex(copy_target_name) {
    visibility = [ ":$template_name" ]

    clear_dir = true
    inputs = [
      binary,
      libraries_list,
    ]
    dest = dist_dir
    rebased_binaries_list = rebase_path([ binary ], root_build_dir)
    rebased_libraries_list = rebase_path(libraries_list, root_build_dir)
    args = [
      "--files=$rebased_binaries_list",
      "--files=@FileArg($rebased_libraries_list:lib_paths)",
    ]

    deps = [
      ":$find_deps_target_name",
    ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }

  group(template_name) {
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }
    deps = [
      ":$copy_target_name",
    ]
  }
}

# Compile a protocol buffer to java.
#
# This generates java files from protocol buffers and creates an Android library
# containing the classes.
#
# Variables
#   sources: Paths to .proto files to compile.
#   proto_path: Root directory of .proto files.
#
# Example:
#  proto_java_library("foo_proto_java") {
#    proto_path = [ "src/foo" ]
#    sources = [ "$proto_path/foo.proto" ]
#  }
template("proto_java_library") {
  set_sources_assignment_filter([])
  _protoc_dep = "//third_party/android_protobuf:android_protoc($host_toolchain)"
  _protoc_out_dir = get_label_info(_protoc_dep, "root_out_dir")
  _protoc_bin = "$_protoc_out_dir/android_protoc"
  _proto_path = invoker.proto_path

  _template_name = target_name

  action("${_template_name}__protoc_java") {
    srcjar_path = "$target_gen_dir/$target_name.srcjar"
    script = "//build/protoc_java.py"
    deps = [
      _protoc_dep,
    ]
    sources = invoker.sources
    depfile = "$target_gen_dir/$target_name.d"
    outputs = [
      depfile,
      srcjar_path,
    ]
    args = [
             "--depfile",
             rebase_path(depfile, root_build_dir),
             "--protoc",
             rebase_path(_protoc_bin, root_build_dir),
             "--proto-path",
             rebase_path(_proto_path, root_build_dir),
             "--srcjar",
             rebase_path(srcjar_path, root_build_dir),
           ] + rebase_path(sources, root_build_dir)
  }

  android_library(target_name) {
    java_files = []
    srcjar_deps = [ ":${_template_name}__protoc_java" ]
    deps = [
      "//third_party/android_protobuf:protobuf_nano_javalib",
    ]
  }
}

# TODO(GYP): implement this.
template("uiautomator_test") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }
  assert(target_name != "")
  assert(invoker.deps != [] || true)
  group(target_name) {
  }
}


template("android_library") {
  _jar_path_file = "$target_gen_dir/$target_name/JAR_PATH"

  generated_file("${target_name}__jar_path") {
    forward_variables_from(invoker, [ "deps", "public_deps" ])
    outputs = [ _jar_path_file ]
    data_keys = [ "jar_path" ]
    walk_keys = [ "jar_path_barrier" ]
  }

  action(target_name) {
    forward_variables_from(invoker, "*")

    if (!defined(jar_path)) {
      if (!defined(jar_name)) {
        jar_name = target_name
      }

      if (!defined(jar_dir)) {
        _target_dir_name = get_label_info(":$target_name", "dir")
        jar_dir = "$root_out_dir/lib.java/$_target_dir_name/$target_name"
      }

      jar_path = "$jar_dir/$jar_name.jar"
    }

    if (!defined(manifest)) {
      manifest = "//build/android/AndroidManifest.xml"
    }

    if (!defined(android_jar)) {
      android_jar = android_sdk_jar
    }

    if (!defined(deps)) {
      deps = []
    }

    deps += [ ":${target_name}__jar_path" ]

    if (!defined(inputs)) {
      inputs = []
    }

    if (defined(source_dirs)) {
      inputs += source_dirs
    }

    if (defined(source_jars)) {
      inputs += source_jars
    }

    if (defined(jar_paths)) {
      inputs += jar_paths
    }

    inputs += [ _jar_path_file ]

    inputs += [ manifest ]

    inputs += [ android_jar ]

    outputs = [
      jar_path,
    ]

    if (defined(resource_dirs)) {
      if (!defined(resource_zip_path)) {
        if (!defined(resource_zip_name)) {
          resource_zip_name = target_name
        }

        if (!defined(resource_zip_dir)) {
          _target_dir_name = get_label_info(":$target_name", "dir")
          resource_zip_dir = "$root_out_dir/resources/$_target_dir_name/$target_name"
        }

        resource_zip_path = "$resource_zip_dir/$resource_zip_name.zip"
      }

      outputs += [ resource_zip_path ]
    }

    depfile = "$target_gen_dir/$target_name.d"

    script = "//build/gyp/create_android_library.py"

    args = [
      "--output-jar", rebase_path(jar_path, root_build_dir),
    ]

    if (defined(resource_zip_path)) {
      args += [
        "--output-resource-zip", rebase_path(resource_zip_path, root_build_dir),
      ]
    }

    if (defined(sources)) {
      foreach(source, sources) {
        args += [
          "--source-file", rebase_path(source, root_build_dir),
        ]
      }
    }

    if (defined(source_dirs)) {
      foreach(source_dir, source_dirs) {
        args += [
          "--source-dir", rebase_path(source_dir, root_build_dir),
        ]
      }
    }

    if (defined(source_jars)) {
      foreach(source_jar, source_jars) {
        args += [
          "--source-jar", rebase_path(source_jar, root_build_dir),
        ]
      }
    }

    if (defined(jar_paths)) {
      foreach(jar_path, jar_paths) {
        args += [
          "--jar-path", rebase_path(jar_path, root_build_dir),
        ]
      }
    }

    args += [
      "--jar-path-file", rebase_path(_jar_path_file, root_build_dir),
    ]

    if (defined(standalone) && standalone) {
      args += [
        "--standalone",
      ]
    }

    if (defined(resource_dirs)) {
      foreach(resource_dir, resource_dirs) {
        args += [
          "--resource-dir", rebase_path(resource_dir, root_build_dir),
        ]
      }
    }

    args += [
      "--manifest", rebase_path(manifest, root_build_dir),
    ]

    args += [
      "--android-jar", rebase_path(android_jar, root_build_dir),
    ]
    
    if (defined(custom_package)) {
      args += [
        "--custom-package", custom_package,
      ]
    }

    args += [
      "--aapt2-binary", rebase_path(android_aapt2_path, root_build_dir),
    ]

    args += [
      "--depfile", rebase_path(depfile, root_build_dir),
    ]

    metadata = {
      jar_path = [ rebase_path(jar_path, root_build_dir) ]
    }

    if (defined(standalone) && standalone) {
      metadata.jar_path_barrier = []
    }

    if (defined(resource_dirs)) {
      metadata.resource_zip = [ rebase_path(resource_zip_path, root_build_dir) ]
    }

    if (defined(custom_package)) {
      metadata.extra_package = [ custom_package ]
    }

    if (defined(assets_dirs)) {
      metadata.assets_dir = []
      foreach(assets_dir, assets_dirs) {
        metadata.assets_dir += rebase_path(assets_dir, root_build_dir)
      }
    }

  }
}

template("android_apk") {
  _jar_path_file = "$target_gen_dir/$target_name/JAR_PATH"

  generated_file("${target_name}__jar_path") {
    forward_variables_from(invoker, [ "deps", "public_deps" ])
    outputs = [ _jar_path_file ]
    data_keys = [ "jar_path" ]
    walk_keys = [ "jar_path_barrier" ]
  }

  _resource_zip_file = "$target_gen_dir/$target_name/RESOURCE_ZIP"

  generated_file("${target_name}__resource_zip") {
    forward_variables_from(invoker, [ "deps", "public_deps" ])
    outputs = [ _resource_zip_file ]
    data_keys = [ "resource_zip" ]
    walk_keys = [ "resource_zip_barrier" ]
  }

  _assets_dir_file = "$target_gen_dir/$target_name/ASSETS_DIR"

  generated_file("${target_name}__assets_dir") {
    forward_variables_from(invoker, [ "deps", "public_deps" ])
    outputs = [ _assets_dir_file ]
    data_keys = [ "assets_dir" ]
    walk_keys = [ "assets_dir_barrier" ]
  }

  _extra_package_file = "$target_gen_dir/$target_name/EXTRA_PACKAGE"

  generated_file("${target_name}__extra_package") {
    forward_variables_from(invoker, [ "deps", "public_deps" ])
    outputs = [ _extra_package_file ]
    data_keys = [ "extra_package" ]
    walk_keys = [ "extra_package_barrier" ]
  }

  action(target_name) {
    forward_variables_from(invoker, "*")

    if (!defined(apk_name)) {
      apk_name = target_name
    }

    apk_path = "$root_out_dir/apks/$apk_name.apk"

    if (!defined(manifest)) {
      manifest = "//build/config/android/AndroidManifest.xml"
    }

    if (!defined(android_jar)) {
      android_jar = android_sdk_jar
    }

    if (!defined(key_path)) {
      key_path = android_default_keystore_path
      key_name = android_default_keystore_name
      key_passwd = android_default_keystore_password
    }

    if (!defined(inputs)) {
      inputs = []
    }

    if (defined(source_dirs)) {
      inputs += source_dirs
    }

    if (defined(source_jars)) {
      inputs += source_jars
    }

    if (defined(jar_paths)) {
      inputs += jar_paths
    }

    inputs += [
      _jar_path_file,
    ]

    if (defined(resource_dirs)) {
      inputs += resource_dirs
    }

    if (defined(resource_zips)) {
      inputs += resource_zips
    }

    if (defined(libraries)) {
      inputs += libraries
    }

    inputs += [
      _resource_zip_file,
    ]

    if (defined(assets_dirs)) {
      inputs += assets_dirs
    }

    inputs += [
      _assets_dir_file,
    ]

    inputs += [
      manifest,
    ]

    inputs += [
      android_jar,
    ]

    inputs += [
      _extra_package_file,
    ]

    inputs += [
      key_path
    ]

    outputs = [
      apk_path,
    ]

    if (!defined(deps)) {
      deps = []
    }

    deps += [
      ":${target_name}__jar_path",
      ":${target_name}__resource_zip",
      ":${target_name}__assets_dir",
      ":${target_name}__extra_package",
    ]

    depfile = "$target_gen_dir/$target_name.d"

    script = "//build/gyp/create_android_apk.py"

    args = [
      "--output-apk", rebase_path(apk_path, root_build_dir),
    ]

    if (defined(sources)) {
      foreach(source, sources) {
        args += [
          "--source-file", rebase_path(source, root_build_dir)
        ]
      }
    }

    if (defined(source_dirs)) {
      foreach(source_dir, source_dirs) {
        args += [
          "--source-dir", rebase_path(source_dir, root_build_dir),
        ]
      }
    }

    if (defined(source_jars)) {
      foreach(source_jar, source_jars) {
        args += [
          "--source-jar", rebase_path(source_jar, root_build_dir)
        ]
      }
    }

    if (defined(jar_paths)) {
      foreach(jar_path, jar_paths) {
        args += [
          "--jar_path", rebase_path(jar_path, root_build_dir),
        ]
      }
    }

    args += [
      "--jar-path-file", rebase_path(_jar_path_file, root_build_dir),
    ]

    if (defined(resource_dirs)) {
      foreach(resource_dir, resource_dirs) {
        args += [
          "--resource-dir", rebase_path(resource_dir, root_build_dir),
        ]
      }
    }

    if (defined(resource_zips)) {
      foreach(resource_zip, resource_zips) {
        args += [
          "--resource-zip", rebase_path(resource_zip, root_build_dir),
        ]
      }
    }

    args += [
      "--resource-zip-file", rebase_path(_resource_zip_file, root_build_dir),
    ]

    if (defined(assets_dirs)) {
      foreach(assets_dir, assets_dirs) {
        args += [
          "--assets-dir", rebase_path(assets_dir, root_build_dir),
        ]
      }
    }

    args += [
      "--assets-dir-file", rebase_path(_assets_dir_file, root_build_dir),
    ]

    args += [
      "--manifest", rebase_path(manifest, root_build_dir), 
    ]

    args += [
      "--android-jar", rebase_path(android_jar, root_build_dir),
    ]

    if (defined(custom_package)) {
      args += [
        "--custom-package", custom_package,
      ]
    }

    if (defined(extra_packages)) {
      foreach(extra_package, extra_packages) {
        args += [
          "--extra-package", extra_package,
        ]
      }
    }

    args += [
      "--key-path", rebase_path(key_path, root_build_dir),
    ]

    if (defined(key_name)) {
      args += [
        "--key-name", key_name,
      ]
    }

    if (defined(key_passwd)) {
      args += [
        "--key-passwd", key_passwd,
      ]
    }

    args += [
      "--extra-package-file", rebase_path(_extra_package_file, root_build_dir),
    ]

    if (defined(libraries)) {
      foreach(library, libraries) {
        args += [
          "--library",
          rebase_path(library, root_build_dir),
        ]
      }
    }

    args += [
      "--aapt2-binary", rebase_path(android_aapt2_path, root_build_dir),
    ]

    args += [
      "--dx-binary", rebase_path(android_dx_path, root_build_dir),
    ]

    args += [
      "--zipalign-binary", rebase_path(android_zipalign_path, root_build_dir),
    ]

    args += [
      "--apksigner-binary", rebase_path(android_apksigner_path, root_build_dir)
    ]

    args += [
      "--depfile", rebase_path(depfile, root_build_dir),
    ]
  }
}
